package meshIneBits.IA.deeplearning;

import meshIneBits.Bit2D;
import meshIneBits.config.CraftConfig;
import meshIneBits.util.Vector2;
import org.datavec.api.transform.analysis.DataAnalysis;
import org.datavec.api.transform.schema.Schema;
import org.datavec.api.util.ndarray.RecordConverter;
import org.datavec.api.writable.Writable;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.util.ModelSerializer;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.DataSet;
import org.nd4j.linalg.dataset.api.preprocessor.NormalizerStandardize;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Vector;

public class NNExploitation {

    MultiLayerNetwork model;
    Schema schema;
    private DataAnalysis analysis;

    public NNExploitation() {
        loadNeuralNet();
    }


    public void loadNeuralNet() {

        File locationToSave = new File("trained_model.zip");

        try {
            MultiLayerNetwork model = ModelSerializer.restoreMultiLayerNetwork(locationToSave);
            //Schema targetSchema = Schema.fromJson(ModelSerializer.getObjectFromFile(locationToSave, "schema"));
            //DataAnalysis analysis = DataAnalysis.fromJson(ModelSerializer.getObjectFromFile(locationToSave, "dataanalysis"));
            this.model = model;
            //this.schema = targetSchema;
            //this.analysis = analysis;
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("Neural network could not be loaded");
        }
    }


    /*
    public double[] getOutputFromNeuralNet(List<Object> rawData) {

        Schema.Builder builder = new Schema.Builder();
        for (int i = 0; i < rawData.size() / 2; i++) {
            builder.addColumnsDouble("x" + i, "y" + i);
        }
        Schema schema = builder.build();

        String[] newOrder = schema.getColumnNames().stream().filter(it -> !it.equals("Exited")).toArray(String[]::new);

        List<Writable> record = RecordConverter.toRecord(schema, rawData);
        List<Writable> transformed = transformProcess.execute(record);
        INDArray data = RecordConverter.toArray(transformed);

        double[] result = model.output(data, false).toDoubleVector();

        return null;
    }

     */

    public double[] getOutputFromNeuralNet(List rawData) {

        NormalizerStandardize normalizer = new NormalizerStandardize();
        normalizer = new NormalizerStandardize();
        normalizer.fit((DataSet) rawData);
        normalizer.transform((INDArray) rawData);
        INDArray rawDataINDArray = RecordConverter.toArray(rawData);

        return model.output(rawDataINDArray, false).toDoubleVector();

    }



    public Bit2D getBit(Vector<Vector2> sectionPoints, Vector2 posLocalSystem, double angleLocalSystem) {

        double[] output = getOutputFromNeuralNet(sectionPoints);

        double edgeAbscissa = output[0];
        double localAngle = output[1];


        return getBitFromNeuralNetworkOutput(edgeAbscissa, localAngle, posLocalSystem, angleLocalSystem);
    }



    /**
     * @param edgeAbscissa     position of a bit, that comes from the neural network's output
     * @param bitLocalAngle    angle of a bit, that comes from the neural network's output
     * @param posLocalSystem   position of the local coordinate system's origin used to prepare data for the neural network
     * @param angleLocalSystem angle of the local coordinate system used to prepare data for the neural network
     * @return the bit's center position in global coordinate system
     */
    public static Bit2D getBitFromNeuralNetworkOutput(double edgeAbscissa, double bitLocalAngle, Vector2 posLocalSystem, double angleLocalSystem) {

        // convert angles in Vector2
        Vector2 bitAngleLocalV2 = Vector2.getEquivalentVector(bitLocalAngle);
        Vector2 angleLocalSystemV2 = Vector2.getEquivalentVector(angleLocalSystem);

        // bit's colinear and orthogonal unit vectors computation
        Vector2 colinear = bitAngleLocalV2.normal();
        Vector2 orthogonal = colinear.rotate(new Vector2(0, -1)); // 90deg anticlockwise rotation

        // bit's center's position in local coordinate system
        Vector2 positionLocal = orthogonal.mul(edgeAbscissa)
                .add(colinear.mul(CraftConfig.bitLength / 2))
                .sub(orthogonal.mul(CraftConfig.bitWidth / 2));

        // bits center's position in global coordinate system
        Vector2 positionGlobal = positionLocal.rotate(angleLocalSystemV2).add(posLocalSystem);

        Vector2 orientationGlobal = bitAngleLocalV2.rotate(angleLocalSystemV2);

        return new Bit2D(positionGlobal, orientationGlobal);
    }







}
