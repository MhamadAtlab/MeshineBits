package meshIneBits.IA.deeplearning;

import meshIneBits.Bit2D;
import meshIneBits.config.CraftConfig;
import meshIneBits.util.Vector2;
import org.datavec.api.transform.analysis.DataAnalysis;
import org.datavec.api.transform.schema.Schema;
import org.datavec.api.util.ndarray.RecordConverter;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.util.ModelSerializer;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.DataSet;
import org.nd4j.linalg.dataset.api.preprocessor.DataNormalization;
import org.nd4j.linalg.dataset.api.preprocessor.NormalizerStandardize;
import org.nd4j.linalg.dataset.api.preprocessor.serializer.NormalizerSerializer;
import org.nd4j.linalg.factory.Nd4j;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Vector;

public class NNExploitation {

    MultiLayerNetwork model;
    DataNormalization normalizer;
    Schema schema;
    private DataAnalysis analysis;

    public NNExploitation() {
        restoreNNParams();
    }


    public void restoreNNParams() {

        try {
            // 1) restore modem
            File locationToSave = new File("trained_model.zip");
            this.model = ModelSerializer.restoreMultiLayerNetwork(locationToSave);

            // 2) restore normalizer
            NormalizerSerializer loader = NormalizerSerializer.getDefault();
            this.normalizer = loader.restore("normalizer_saved");

        } catch (Exception e) {
            System.out.println("Neural Network parameters could not be restored");
        }
    }

    public double[] getOutputFromNeuralNet(Vector<Double> features) {
        INDArray featuresIND = Nd4j.create(features);
        normalizer.transform(featuresIND);
        double[] predictedlabels = model.output(featuresIND, false).toDoubleVector();
        return predictedlabels;
    }

    public double[] getOutputFromNeuralNet(List rawData) {

        NormalizerStandardize normalizer = new NormalizerStandardize();
        normalizer = new NormalizerStandardize();
        normalizer.fit((DataSet) rawData);
        normalizer.transform((INDArray) rawData);
        INDArray rawDataINDArray = RecordConverter.toArray(rawData);

        return model.output(rawDataINDArray, false).toDoubleVector();
    }



    public Bit2D getBit(Vector<Vector2> sectionPoints, Vector2 posLocalSystem, double angleLocalSystem) {

        double[] output = getOutputFromNeuralNet(sectionPoints);

        double edgeAbscissa = output[0];
        double localAngle = output[1];


        return getBitFromNeuralNetworkOutput(edgeAbscissa, localAngle, posLocalSystem, angleLocalSystem);
    }



    /**
     * @param edgeAbscissa     position of a bit, that comes from the neural network's output
     * @param bitLocalAngle    angle of a bit, that comes from the neural network's output
     * @param posLocalSystem   position of the local coordinate system's origin used to prepare data for the neural network
     * @param angleLocalSystem angle of the local coordinate system used to prepare data for the neural network
     * @return the bit's center position in global coordinate system
     */
    public static Bit2D getBitFromNeuralNetworkOutput(double edgeAbscissa, double bitLocalAngle, Vector2 posLocalSystem, double angleLocalSystem) {

        // convert angles in Vector2
        Vector2 bitAngleLocalV2 = Vector2.getEquivalentVector(bitLocalAngle);
        Vector2 angleLocalSystemV2 = Vector2.getEquivalentVector(angleLocalSystem);

        // bit's colinear and orthogonal unit vectors computation
        Vector2 colinear = bitAngleLocalV2.normal();
        Vector2 orthogonal = colinear.rotate(new Vector2(0, -1)); // 90deg anticlockwise rotation

        // bit's center's position in local coordinate system
        Vector2 positionLocal = orthogonal.mul(edgeAbscissa)
                .add(colinear.mul(CraftConfig.bitLength / 2))
                .sub(orthogonal.mul(CraftConfig.bitWidth / 2));

        // bits center's position in global coordinate system
        Vector2 positionGlobal = positionLocal.rotate(angleLocalSystemV2).add(posLocalSystem);

        Vector2 orientationGlobal = bitAngleLocalV2.rotate(angleLocalSystemV2);

        return new Bit2D(positionGlobal, orientationGlobal);
    }







}
