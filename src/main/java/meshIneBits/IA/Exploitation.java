package meshIneBits.IA;

import meshIneBits.Bit2D;
import meshIneBits.IA.IA_util.AI_Exception;
import meshIneBits.config.CraftConfig;
import meshIneBits.slicer.Slice;
import meshIneBits.util.Segment2D;
import meshIneBits.util.Vector2;

import java.util.Map;
import java.util.Vector;

public class Exploitation {
    private AI_Tool ai_tool;

    public Exploitation(AI_Tool ai_tool) {
        this.ai_tool = ai_tool;
    }

    public void placeBitsOnSlices(Map<Slice, Vector<Segment2D>> sliceMap) throws AI_Exception {
        Bit2D newBit = null;
        for (Slice currentSlice : sliceMap.keySet()) { //place tous les bits de chaque Slice
            Vector<Vector<Vector2>> contoursPoints = ai_tool.dataPrep.getBoundsAndRearrange(sliceMap, currentSlice);
            boolean firstBitOfContour = true;
            for (Vector<Vector2> contour : contoursPoints) { //place tous les bits de chaque contour
                Vector2 startPoint;
                if (firstBitOfContour) {
                    firstBitOfContour = false;
                    startPoint = contour.get(0);
                } else {
                    startPoint = ai_tool.dataPrep.getNextBitStartPoint(newBit, contour);
                }
                Vector<Vector2> sectionPoints = ai_tool.dataPrep.getBitAssociatedPoints(startPoint);//getSectionToPlaceNewBit(contour, startPoint);
                Vector<Vector2> sectionLocal = ai_tool.dataPrep.getSectionInLocalCoordinateSystem(sectionPoints);

                Vector<Vector> coeffs = ai_tool.dataPrep.getInputSlopesForDL(sectionLocal);
                Vector<Vector2> inputPoints = ai_tool.dataPrep.getInputPointsForDL(sectionLocal);
                newBit = placeBitWithNN(coeffs, inputPoints);
                //todo voir comment on l'ajoute à la slice, et l'affiche à l'écran
            }
        }
    }

    /**
     * Place a bit2D with the neural network
     *
     * @param coeffs      the coefficients from the curve model
     * @param inputPoints the raw input points on which the bit will be placed
     * @return a new Bit2D with its position and orientation
     */
    public Bit2D placeBitWithNN(Vector<Vector> coeffs, Vector<Vector2> inputPoints) {
        //todo
        return new Bit2D(new Vector2(0, 0), new Vector2(0, 0));
        //ANDRE todo pas oublier de remettre dans le bon repère
    }

    /**
     * @param bitPos           position of a bit, that comes from the neural network's output
     * @param bitAngle         angle of a bit, that comes from the neural network's output
     * @param posLocalSystem   position of the local coordinate system's origin used to prepare data for the neural network
     * @param angleLocalSystem angle of the local coordinate system used to prepare data for the neural network
     * @return the bit's center position in global coordinate system
     */
    public Vector2 getBitPositionInGlobalCoordinateSystem(double bitPos, Vector2 bitAngle, Vector2 posLocalSystem, Vector2 angleLocalSystem) {

        // bit's colinear and orthogonal unit vectors computation
        Vector2 colinear = bitAngle.normal();
        Vector2 orthogonal = colinear.rotate(new Vector2(0, 1)); // 90deg anticlockwise rotation

        // bit's center's position in local coordinate system
        Vector2 positionLocal = colinear.mul(CraftConfig.bitLength / 2)
                .add(orthogonal.mul(CraftConfig.bitWidth / 2))
                .sub(orthogonal.mul(bitPos));

        // bits center's position in global coordinate system
        Vector2 positionGlobal = positionLocal.rotate(angleLocalSystem).add(posLocalSystem);

        System.out.println("colinear = " + colinear);
        System.out.println("orth = " + orthogonal);
        System.out.println("position local =" + positionLocal);

        return positionGlobal;
    }

}
