package meshIneBits.artificialIntelligence.deepLearning;

import meshIneBits.Bit2D;
import meshIneBits.artificialIntelligence.AI_Tool;
import meshIneBits.config.CraftConfig;
import meshIneBits.util.Vector2;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.util.ModelSerializer;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.preprocessor.DataNormalization;
import org.nd4j.linalg.dataset.api.preprocessor.serializer.NormalizerSerializer;
import org.nd4j.linalg.factory.Nd4j;

import java.io.File;
import java.util.Arrays;
import java.util.Vector;

public class NNExploitation {

    MultiLayerNetwork model;
    DataNormalization normalizer;


    public NNExploitation() {
        restoreNNParams();
    }


    public void restoreNNParams() {
        try {
            // 1) restore modem
            File locationToSave = new File(AI_Tool.MODEL_PATH);
            this.model = ModelSerializer.restoreMultiLayerNetwork(locationToSave);

            // 2) restore normalizer
            NormalizerSerializer loader = NormalizerSerializer.getDefault();
            this.normalizer = loader.restore(AI_Tool.NORMALIZER_PATH);
            System.out.println("Model and Normalizer restored succesfully");

        } catch (Exception e) {
            System.out.println("Neural Network parameters or normalizer could not be restored");
        }
    }

    public double[] getOutputFromNeuralNet(double[][] features) {
        INDArray featuresIND = Nd4j.create(features);
        normalizer.transform(featuresIND);
        return model.output(featuresIND, false).toDoubleVector();
    }

    public Bit2D getBit(Vector<Vector2> sectionPoints, Vector2 posLocalSystem, double angleLocalSystem) {

        double[][] featuresArray = new double[1][sectionPoints.size()*2];

        int iFeature = 0;
        for(Vector2 point : sectionPoints){
            featuresArray[0][iFeature] = point.x; iFeature++;
            featuresArray[0][iFeature] = point.y; iFeature++;
        }

        double[] output = getOutputFromNeuralNet(featuresArray);

        double edgeAbscissa = output[0];
        double localAngle = output[1];


        return getBitFromNeuralNetworkOutput(edgeAbscissa, localAngle, posLocalSystem, angleLocalSystem);
    }


    /**
     * todo doc
     * @param edgeAbscissa     position of a bit, that comes from the neural network's output
     * @param bitLocalAngle    angle of a bit, that comes from the neural network's output
     * @param posLocalSystem   position of the local coordinate system's origin used to prepare data for the neural network
     * @param angleLocalSystem angle of the local coordinate system used to prepare data for the neural network
     * @return the bit's center position in global coordinate system
     */
    public Bit2D getBitFromNeuralNetworkOutput(double edgeAbscissa, double bitLocalAngle, Vector2 posLocalSystem, double angleLocalSystem) {
        edgeAbscissa += AI_Tool.paramPosCorrection.getCurrentValue();

        // convert angles in Vector2
        Vector2 bitAngleLocalV2 = Vector2.getEquivalentVector(bitLocalAngle);
        Vector2 angleLocalSystemV2 = Vector2.getEquivalentVector(angleLocalSystem);

        // bit's colinear and orthogonal unit vectors computation
        Vector2 colinear = bitAngleLocalV2.normal();
        Vector2 orthogonal = colinear.rotate(new Vector2(0, -1)); // 90deg anticlockwise rotation

        // bit's center's position in local coordinate system
        Vector2 positionLocal = orthogonal.mul(edgeAbscissa)
                .add(colinear.mul(CraftConfig.bitLength / 2))
                .sub(orthogonal.mul(CraftConfig.bitWidth / 2));

        // bits center's position in global coordinate system
        Vector2 positionGlobal = positionLocal.rotate(angleLocalSystemV2).add(posLocalSystem);

        Vector2 orientationGlobal = bitAngleLocalV2.rotate(angleLocalSystemV2);

        return new Bit2D(positionGlobal, orientationGlobal);
    }


}
